clc
close all
clear all

file = fopen('data6.txt');
X = fscanf(file, '%f', [2 inf])';
fclose(file);
% X(6:100,:) = []; % удалить строки с 6 по 100, то есть оставить первых 5
% X % тут это уже не нужно но интересный факт
x = X(:,1);
y = X(:,2);
N = size(X);
K = N(2); % =2
N = N(1); % =100

figure;
subplot(1,2,1); % первое число это на сколько строк разбивается координатная плоскость, 
% второе - на сколько столбцов, третье - в каком по счёту из образованных
% секторов расположить текущий график. Если не вызывать figure перед
% следующим графиком, а перед scatter (или например plot) вызвать subplot,
% второй график нарисуется в том же окне в другом секторе. Нумерация
% секторов идёт с первой строки слева направо, потом по второй строке слева направо и т.д.
scatter(x, y, 35); % 35 - размер
title('Экспериментальные данные');
xlabel('X2');
ylabel('X1');

k = 4; % визуаль кажется отбалды столько кластеров, выбрать надо визуально
C = zeros(k, K); % центры кластеров
for i = 1:k
    C(i,:) = X(i,:); % пока что просто переписали первые k значений исходных данных
end;

U = zeros(N, 2); % в матрице U находится [индекс кластера, расстояние от объекта до центра]
Q_pred = 1435; % значение функционала качества кластеризации на предыдущем шаге (изначально просто больше лучше)
eps = 0.0001435; % точность
m = 1; % номер итерации
clust_rad = zeros(1, k); % массив радиусов каждого из кластеров

while (true) % // мы не намерены завершаться
    R = zeros(1, k); % для каждого из объектов (одного на данной итерации, потом обнуляется и снова)
    for i = 1:N % расчёт расстояний до центров кластеров, заполнение матрицы U
        for n = 1:k
        R(n) = pdist([X(i,:); C(n,:)], 'euclidean'); % расстояние i-го объекта до каждого из центров
        end 
        
        [zatychka, n] = min(R); % записать в n номер ближайшего центра кластера, 
        % затычка просто потому что я не нашёл функции отдельно для нахождения исключительно индекса
        U(i,1) = n; % до какого центра минимальное расстояние i-го объекта, к тому и относить его
        U(i,2) = R(n); % само расстояние до центра
    end
    
    
    % качеством является сумма внутрикластерных расстояний между объектами
    % тебе для 1-го варианта достаточно использовать Q_m = Q_m + U(Obj(i),2); в цикле от 1 до s без последующих хехов
    Q_m = 0; % качество кластеризации на текущем шаге для p-го кластера
    QQ = 0; % качество кластеризации на текущем шаге суммарное
    for p = 1:k % для кажого из кластеров
        Obj = find(U(:,1)==p); % какие из объектов относятся к p-му кластеру (их порядковый номер)
        s = length(Obj); % сколько таких относится
        singl_clust = zeros(1, s);
        X_clust = zeros(s, 2);
        for i = 1:s % цикл по всем элементам p-го кластера
            singl_clust(i) = U(Obj(i), 2); % расстояние до центра i-го кластера
            X_clust(i,:) = X(Obj(i),:); % переписать в новую матрицу только те объекты которые в p-ом кластере 
        end;
        xex = pdist(X_clust); % euclidean по умолчанию, расстояние между точками кластера
        Q_m = sum(xex); % сумма расстояний
        clust_rad(p) = max(singl_clust); % радиус кластера это максимальное расстояние от центра до какого-либо его объекта
        QQ = QQ + Q_m;
    end;
    
    % если на двух соседних шагах качество кластеризации почти не изменилось значит дальнейший пересчёт нецелесообразен
    if abs(QQ - Q_pred) <= eps
        break;
    else % если заданное качество не достигнуто, то пересчитываем центры как среднее по каждому признаку
        for l = 1:k % по каждому кластеру
             Obj = find(U(:,1)==l); % какие из объектов относятся к l-му кластеру
             s = length(Obj); % сколько таких относится
             for j = 1:K % по каждому признаку, то есть среднее по иксам и среднее по игрекам
                summa = 0;
                for i = 1:s 
                    summa = summa + X(Obj(i), j);
                end;
                C(l,j) = summa/s; % среднее
             end;
        end;
        Q_pred = QQ; % изменяем качество кластеризации
        m = m + 1; % итерации
    end;
end;

% отображение найденных кластеров и центров
subplot(1,2,2);
gscatter(x, y, U(:,1), '', '.', 15);
hold on;
t = 0:(pi/180):2*pi;
for i = 1:k % oval
  x = clust_rad(i)*cos(t) + C(i,1);
  y = clust_rad(i)*sin(t) + C(i,2);
  plot(x, y, 'k');
end;
scatter(C(:,1), C(:,2), 20, 'k', 'filled'); % центры
title('Найденные кластеры и их центры');
xlabel('X2');
ylabel('X1');
